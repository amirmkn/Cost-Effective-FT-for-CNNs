import torch
import torch.nn as nn

class VulnerabilityAnalyzer:

    def __init__(self, model, device):
        self.model = model
        self.device = device
        self.model.eval()

    def analyze(self, dataloader, max_batches=1):

        vuln = {}

        target_modules = []
        for name, module in self.model.named_modules():
            if isinstance(module, (nn.Conv2d, nn.Linear)):
                module.weight.requires_grad_(True)
                target_modules.append((name, module))

        for b_idx, (x, y) in enumerate(dataloader):
            if b_idx >= max_batches:
                break

            x, y = x.to(self.device), y.to(self.device)
            batch_size = x.size(0)

            for b in range(batch_size):

                self.model.zero_grad()
                out = self.model(x[b].unsqueeze(0))
                num_classes = out.size(1)

                target_class = y[b]
                Zt = out[0, target_class]


                grad_t = torch.autograd.grad(
                    Zt,
                    [module.weight for _, module in target_modules],
                    retain_graph=True
                )

                for i in range(num_classes):

                    if i == target_class:
                        continue

                    Zi = out[0, i]
                    denom = (Zi - Zt).detach().pow(2) + 1e-12

                    grad_i = torch.autograd.grad(
                        Zi,
                        [module.weight for _, module in target_modules],
                        retain_graph=True
                    )

                    for (name, module), g_i, g_t in zip(target_modules, grad_i, grad_t):

                        g_diff = g_i - g_t

                        if isinstance(module, nn.Conv2d):
                            score = g_diff.pow(2).sum(dim=(1,2,3)) / denom
                        else:
                            score = g_diff.pow(2).sum(dim=1) / denom

                        if name not in vuln:
                            vuln[name] = score.detach().clone()
                        else:
                            vuln[name] += score.detach()

                # آزادسازی
                del grad_t
                torch.cuda.empty_cache()

        result = {}
        for k, v in vuln.items():
            vals = v.cpu().tolist()
            sorted_idx = sorted(range(len(vals)), key=lambda i: vals[i], reverse=True)
            result[k] = {
                "scores": vals,
                "sorted_idx": sorted_idx
            }

        return result
