import torch
import torch.nn as nn
from collections import defaultdict

class VulnerabilityAnalyzer:
    """
    Analyzes a model to identify vulnerable weights in Conv2d
    and Linear layers based on their gradient sensitivity (Eq.1).
    """

    def __init__(self, model, device):
        self.model = model
        self.device = device
        self.model.eval()

    def analyze(self, dataloader, max_batches=1):
        vuln = {}

        target_modules = []
        for name, module in self.model.named_modules():
            if isinstance(module, (nn.Conv2d, nn.Linear)):
                module.weight.requires_grad = True
                target_modules.append((name, module))

        for b_idx, (x, y) in enumerate(dataloader):
            if b_idx >= max_batches:
                break

            x, y = x.to(self.device), y.to(self.device)
            output = self.model(x)  # shape: [batch, num_classes]

            batch_size, num_classes = output.shape

            for b in range(batch_size):
                Zt = output[b, y[b]]

                for i in range(num_classes):
                    if i == y[b]:
                        continue

                    diff = output[b, i] - Zt  # Zi - Zt
                    denom = diff.detach().pow(2) + 1e-12

                    self.model.zero_grad()
                    diff.backward(retain_graph=True)

                    for name, module in target_modules:
                        g = module.weight.grad
                        if g is None:
                            continue

                        if isinstance(module, nn.Conv2d):
                            score = g.pow(2).sum(dim=(1,2,3)) / denom
                        else:
                            score = g.pow(2).sum(dim=1) / denom

                        if name not in vuln:
                            vuln[name] = score.detach().clone()
                        else:
                            vuln[name] += score.detach()


        result = {}
        for k, v in vuln.items():
            vals = v.cpu().tolist()
            sorted_idx = sorted(range(len(vals)), key=lambda i: vals[i], reverse=True)
            result[k] = {"scores": vals, "sorted_idx": sorted_idx}

        return result
